(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{417:function(s,n,t){"use strict";t.r(n);var e=t(27),a=Object(e.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"防抖和节流的区分和实现详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流的区分和实现详解"}},[s._v("#")]),s._v(" 防抖和节流的区分和实现详解")]),s._v(" "),t("Pv",{attrs:{id:1}}),s._v(" "),t("p",[s._v("在网页运行的某些场景中，有些事件会不间断的被触发。如"),t("code",[s._v("scroll")]),s._v("事件并不是我们想象中的，滚动一次触发一次。而是会多次被触发，由于过于频繁地"),t("code",[s._v("DOM")]),s._v("操作和资源加载，严重影响了网页性能，甚至会造成浏览器崩溃。")]),s._v(" "),t("h2",{attrs:{id:"常见的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的应用场景"}},[s._v("#")]),s._v(" 常见的应用场景")]),s._v(" "),t("ol",[t("li",[s._v("最常见的场景 "),t("code",[s._v("scroll")]),s._v(" 事件。\n如下。当我们对窗口增加滚动事件监听，然后每次滚动时，触发监听的回调函数。")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("function printScroll  () {\n    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n　　console.log('滚动条当前位置：' + scrollTop);\n}\nwindow.addEventListener('scroll', printScroll)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("但是，在运行时我们发现"),t("strong",[s._v("滚动一下")]),s._v("会"),t("strong",[s._v("触发多次")]),s._v("回调函数，打印结果如下：\n")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:s.$withBase("/img/javascript/scroll.png"),alt:"滚动",title:"滚动打印",width:"auto",height:"auto"}})]),s._v("\n然而实际开发中我们并不需要如此高频的回调，毕竟浏览器的性能是有限的，不应该浪费在这里。那么如何优化这种情况了。"),t("p"),s._v(" "),t("h2",{attrs:{id:"防抖-debounce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防抖-debounce"}},[s._v("#")]),s._v(" 防抖(debounce)")]),s._v(" "),t("p",[s._v("含义：事件被触发后延迟n秒再执行回调，如果在这n秒内又被触发，则重新计时。")]),s._v(" "),t("p",[s._v("具体实现：原理就是利用闭包。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 防抖函数（简洁版）\nfunction debounce(fn,delay){\n    let timer = null //借助闭包\n    return function() {\n        if(timer){\n            clearTimeout(timer) \n        }\n        timer = setTimeout(fn, delay)\n    }\n}\n// 原始函数\nlet handlerScroll = function() {\n    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n　　console.log('滚动条当前位置：' + scrollTop);\n}\n// 两函数结合，实现滚动防抖\nwindow.addEventListener('scroll', debounce(handlerScroll, 1000))\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("p",[s._v("此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。\n注：实际开发中需要通过apply来获取函数的作用域和变量"),t("code",[s._v("fn.apply(context, args)")]),s._v("。")]),s._v(" "),t("p",[s._v("实际开发中需要防抖处理的场景还是非常多的，如"),t("code",[s._v("resize事件")]),s._v("、"),t("code",[s._v("scroll事件")]),s._v("、"),t("code",[s._v("input事件")]),s._v("、"),t("code",[s._v("拖拽事件")]),s._v("等。除了这些,还有很多情况需要我们结合实际开发处理。")]),s._v(" "),t("h2",{attrs:{id:"节流-throttle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#节流-throttle"}},[s._v("#")]),s._v(" 节流(throttle)")]),s._v(" "),t("p",[s._v("顾名思义就是每过n秒仅执行一次回调函数。如单位时间内多次触发函数，也只有一次生效。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 节流函数\nfunction throttle(fn, delay) {\n    let timer = null;      //定义一个定时器\n    return function() {\n        let context = this;\n        let args = arguments;\n        if(!timer) {\n            timer = setTimeout(function() {\n                fn.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\n// 原始函数\nlet scrollEvent = function() {\n　　console.log('当前时间戳：' + new Date().getTime());\n}\n// 滚动事件\nwindow.addEventListener('scroll', throttle(scrollEvent, 1000));\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br")])]),t("p",[s._v("连续滚动5s的实际效果：\n")]),t("div",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:s.$withBase("/img/javascript/scroll1.png"),alt:"滚动",title:"滚动打印",width:"auto",height:"auto"}})]),s._v("\n由于"),t("code",[s._v("setTimeout")]),s._v("函数的时间参数存在误差，所以打印的结果后三位不一定是我们期望的数值。节流函数除了利用定时器的方式，也可以利用时间戳的方式。当前时间与上一个时间进行比对，这里就不赘述了。"),t("p"),s._v(" "),t("h2",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[s._v("#")]),s._v(" 区别")]),s._v(" "),t("p",[s._v("综上所述，防抖是事件停止触发且过了某指定时间后执行一次，而函数节流是间隔某指定的单位时间执行一次。")]),s._v(" "),t("p",[s._v("防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象，作为大前端开发人员是应该熟练掌握的技能。")]),s._v(" "),t("Vssue",{attrs:{title:"vssue-blog"}})],1)}),[],!1,null,null,null);n.default=a.exports}}]);